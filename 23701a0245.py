# -*- coding: utf-8 -*-
"""23701A0245.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v3DY-Uf8DksTWotmXQGj0bG1qJKNBf4n
"""

import numpy as np
import matplotlib.pyplot as plt

class LiIonBattery:
    def __init__(self, capacity_Ah, voltage_V):
        self.capacity_Ah = capacity_Ah
        self.voltage_V = voltage_V
        self.capacity_Wh = capacity_Ah * voltage_V  # total energy capacity (Watt-hour)
        self.energy_Wh = 0.5 * self.capacity_Wh    # start at 50% SOC
        self.soc = 0.5                             # initial SOC (0-1)

    def charge(self, current_A, time_h):
        energy_in = current_A * self.voltage_V * time_h  # energy input in Wh
        # Update stored energy
        self.energy_Wh += energy_in
        # Prevent overcharge
        if self.energy_Wh > self.capacity_Wh:
            self.energy_Wh = self.capacity_Wh

        self.soc = self.energy_Wh / self.capacity_Wh

        efficiency = self._efficiency(charge=True)
        return self.soc, efficiency

    def discharge(self, current_A, time_h):
        energy_out = current_A * self.voltage_V * time_h  # energy output in Wh
        # Update stored energy
        self.energy_Wh -= energy_out
        # Prevent overdischarge
        if self.energy_Wh < 0:
            self.energy_Wh = 0

        self.soc = self.energy_Wh / self.capacity_Wh

        efficiency = self._efficiency(charge=False)
        return self.soc, efficiency

    def _efficiency(self, charge=True):
        if charge:
            return 0.95 - 0.1 * self.soc
        else:
            return 0.85 + 0.1 * self.soc

def main():
    # Inputs from user
    capacity = float(input("Enter battery capacity (Ah): "))
    voltage = float(input("Enter battery voltage (V): "))
    current = float(input("Enter current (A) for charging/discharging: "))
    time = float(input("Enter time duration (hours): "))

    battery = LiIonBattery(capacity, voltage)

    # Simulate charging
    soc, eff = battery.charge(current, time)
    print(f"After charging: SOC = {soc*100:.2f}%, Efficiency = {eff*100:.2f}%")

    # Simulate discharging
    soc, eff = battery.discharge(current, time)
    print(f"After discharging: SOC = {soc*100:.2f}%, Efficiency = {eff*100:.2f}%")

    # Plot SOC and efficiency over charge and discharge cycle
    times = [0, time, 2*time]
    soc_values = [0.5*100, soc*100 + (soc - 0.5)*100, soc*100]  # approx progression
    eff_values = [battery._efficiency(True)*100, eff*100, battery._efficiency(False)*100]

    plt.figure(figsize=(8,5))
    plt.plot(times[:2], [50, soc*100], 'bo-', label='SOC (%)')
    plt.plot(times[:2], [battery._efficiency(True)*100, eff*100], 'go-', label='Efficiency (%) during charge')
    plt.plot(times[1:], [eff*100, battery._efficiency(False)*100], 'ro-', label='Efficiency (%) during discharge')

    plt.xlabel("Time (hours)")
    plt.title("Li-ion Battery SOC and Efficiency")
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()