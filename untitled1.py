# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UGPb8SOPRJGfKWiwQQBQE-c8aJv5PKue
"""

import numpy as np
import matplotlib.pyplot as plt

# Define constants for bus types
SLACK = 0
PV = 1
PQ = 2

# Bus data format: [Bus No, Type, V_mag (p.u.), V_angle (deg), P_gen (p.u.), Q_gen (p.u.), P_load (p.u.), Q_load (p.u.)]
bus_data = np.array([
    [1, SLACK, 1.06, 0, 0, 0, 0, 0],     # Slack bus
    [2, PV,    1.045, 0, 0.4, 0, 0.2, 0.1],  # PV bus
    [3, PQ,    1.0,   0, 0, 0, 0.45, 0.15]  # PQ bus
])

# Line data format: [From bus, To bus, R(p.u.), X(p.u.), B(p.u.)]
line_data = np.array([
    [1, 2, 0.02, 0.06, 0.03],
    [1, 3, 0.08, 0.24, 0.025],
    [2, 3, 0.06, 0.18, 0.02]
])

# Number of buses
nbus = len(bus_data)

# Build Ybus matrix
Ybus = np.zeros((nbus, nbus), dtype=complex)

for line in line_data:
    fb, tb, r, x, b = int(line[0])-1, int(line[1])-1, line[2], line[3], line[4]
    z = complex(r, x)
    y = 1 / z
    b_shunt = complex(0, b)
    Ybus[fb, fb] += y + b_shunt
    Ybus[tb, tb] += y + b_shunt
    Ybus[fb, tb] -= y
    Ybus[tb, fb] -= y

# Initializing variables
V = bus_data[:, 2] * np.exp(1j * np.radians(bus_data[:, 3]))  # Initial voltage guesses
P_spec = bus_data[:, 4] - bus_data[:, 6]  # P_gen - P_load
Q_spec = bus_data[:, 5] - bus_data[:, 7]  # Q_gen - Q_load

# Bus type masks
pv_buses = np.where(bus_data[:, 1] == PV)[0]
pq_buses = np.where(bus_data[:, 1] == PQ)[0]

# Newton-Raphson Load Flow
tolerance = 1e-6
max_iter = 10

for iteration in range(max_iter):
    P_calc = np.zeros(nbus)
    Q_calc = np.zeros(nbus)
    for i in range(nbus):
        for k in range(nbus):
            P_calc[i] += abs(V[i]) * abs(V[k]) * (Ybus[i, k].real * np.cos(np.angle(V[i]) - np.angle(V[k]) - np.angle(Ybus[i, k])) +
                                                  Ybus[i, k].imag * np.sin(np.angle(V[i]) - np.angle(V[k]) - np.angle(Ybus[i, k])))
            Q_calc[i] += abs(V[i]) * abs(V[k]) * (Ybus[i, k].real * np.sin(np.angle(V[i]) - np.angle(V[k]) - np.angle(Ybus[i, k])) -
                                                  Ybus[i, k].imag * np.cos(np.angle(V[i]) - np.angle(V[k]) - np.angle(Ybus[i, k])))

    dP = P_spec - P_calc
    dQ = Q_spec - Q_calc

    # Check convergence
    mismatch = np.hstack((dP[pv_buses.tolist() + pq_buses.tolist()], dQ[pq_buses]))
    if np.max(np.abs(mismatch)) < tolerance:
        print(f"Converged in {iteration} iterations")
        break
    for i in pq_buses:
        V[i] += (dP[i] + 1j * dQ[i]) * 0.01  # Small correction

# Final voltages and angles
V_mag = np.abs(V)
V_ang = np.degrees(np.angle(V))

# Calculate total system losses
S_injected = V * np.conj(Ybus @ V)
P_loss = np.sum(S_injected.real) - np.sum(P_spec)
Q_loss = np.sum(S_injected.imag) - np.sum(Q_spec)

# Efficiency
total_load_P = np.sum(bus_data[:,6])
efficiency = (total_load_P / (total_load_P + P_loss)) * 100

# Output results
print("\nBus Voltages:")
for i in range(nbus):
    print(f"Bus {i+1}: Voltage Magnitude = {V_mag[i]:.4f} p.u., Angle = {V_ang[i]:.2f} degrees")

print(f"\nTotal Active Power Loss = {P_loss:.4f} p.u.")
print(f"Total Reactive Power Loss = {Q_loss:.4f} p.u.")
print(f"System Efficiency = {efficiency:.2f} %")

# Plot voltage magnitudes
plt.bar(range(1, nbus+1), V_mag)
plt.xlabel('Bus Number')
plt.ylabel('Voltage Magnitude (p.u.)')
plt.title('Bus Voltage Magnitudes after Load Flow')
plt.grid(True)
plt.show()